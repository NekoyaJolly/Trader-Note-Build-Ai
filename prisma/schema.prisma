generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// ユーザー（JWT認証用）
model User {
  id                String             @id @default(uuid()) @db.Uuid
  /// メールアドレス（ログインID）
  email             String             @unique
  /// ハッシュ化されたパスワード（bcrypt）
  passwordHash      String
  /// ユーザー名（表示用）
  displayName       String?
  /// ロール
  role              UserRole           @default(user)
  /// アカウント有効フラグ
  active            Boolean            @default(true)
  /// リフレッシュトークン（ローテーション用）
  refreshToken      String?
  /// 最終ログイン日時
  lastLoginAt       DateTime?          @db.Timestamptz(6)
  /// 作成日時
  createdAt         DateTime           @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt         DateTime           @updatedAt @db.Timestamptz(6)
  pushSubscriptions PushSubscription[] @relation("UserPushSubscriptions")
  watchlists        Watchlist[]

  @@index([email], map: "idx_user_email")
  @@index([active], map: "idx_user_active")
}

/// ウォッチリスト（監視対象シンボル）
/// 日次OHLCV蓄積の対象シンボルを管理
model Watchlist {
  id         String   @id @default(uuid()) @db.Uuid
  /// ユーザー ID
  userId     String   @db.Uuid
  /// シンボル（例: USDJPY, EURUSD, XAUUSD）
  symbol     String
  /// 取得する時間足（例: ["15m", "1h", "4h"]）
  timeframes String[] @default(["15m", "1h"])
  /// 有効フラグ
  active     Boolean  @default(true)
  /// メモ（例: 主要通貨ペア）
  notes      String?
  /// 作成日時
  createdAt  DateTime @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt  DateTime @updatedAt @db.Timestamptz(6)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, symbol], map: "uq_watchlist_user_symbol")
  @@index([userId, active], map: "idx_watchlist_user_active")
  @@index([active], map: "idx_watchlist_active")
}

model Trade {
  id        String     @id @default(uuid()) @db.Uuid
  timestamp DateTime   @db.Timestamptz(6)
  symbol    String
  side      TradeSide
  price     Decimal    @db.Decimal(18, 8)
  quantity  Decimal    @db.Decimal(18, 8)
  fee       Decimal?   @db.Decimal(18, 8)
  exchange  String?
  createdAt DateTime   @default(now()) @db.Timestamptz(6)
  updatedAt DateTime   @updatedAt @db.Timestamptz(6)
  note      TradeNote?

  @@index([symbol, timestamp], map: "idx_trade_symbol_timestamp")
}

model TradeNote {
  id               String            @id @default(uuid()) @db.Uuid
  tradeId          String            @unique @db.Uuid
  symbol           String
  entryPrice       Decimal           @db.Decimal(18, 8)
  side             TradeSide
  indicators       Json?
  featureVector    Float[]
  timeframe        String?
  createdAt        DateTime          @default(now()) @db.Timestamptz(6)
  updatedAt        DateTime          @updatedAt @db.Timestamptz(6)
  /// 有効化日時
  activatedAt      DateTime?         @db.Timestamptz(6)
  /// 最終編集日時
  lastEditedAt     DateTime?         @db.Timestamptz(6)
  /// トレード時点の市場コンテキスト（JSON: trend, calculatedIndicators等）
  marketContext    Json?
  /// アーカイブ日時
  archivedAt       DateTime?         @db.Timestamptz(6)
  /// 承認状態（draft: 下書き、active: 有効、archived: アーカイブ）
  status           NoteStatus        @default(draft)
  /// タグ（検索用）
  tags             String[]          @default([])
  /// ユーザーによる追記コメント
  userNotes        String?
  /// ノート固有のインジケーター設定（NoteIndicatorConfig 型の JSON）
  /// グローバル設定とは別に、このノート独自の評価ロジックを定義可能
  indicatorConfig  Json?
  
  // === フェーズ8: 複数ノート運用UX ===
  /// ノート優先度（1-10、高いほど優先。同時ヒット時のソートに使用）
  priority         Int               @default(5)
  /// 有効フラグ（false の場合、マッチング対象から除外）
  enabled          Boolean           @default(true)
  /// 一時停止（この日時まで無効。null の場合は停止なし）
  pausedUntil      DateTime?         @db.Timestamptz(6)
  
  aiSummary               AISummary?
  backtestRuns            BacktestRun[]
  evaluationLogs          EvaluationLog[]          @relation("EvaluationLogNote")
  matchResult             MatchResult[]
  notificationLogs        NotificationLog[]        @relation("NotificationLogNote")
  notificationSkipLogs    NotificationSkipLog[]    @relation("NotificationSkipLogNote")
  trade                   Trade                    @relation(fields: [tradeId], references: [id])

  @@index([symbol], map: "idx_tradenote_symbol")
  @@index([status], map: "idx_tradenote_status")
  @@index([symbol, status], map: "idx_tradenote_symbol_status")
  @@index([enabled, status], map: "idx_tradenote_enabled_status")
  @@index([priority], map: "idx_tradenote_priority")
}

model AISummary {
  id               String    @id @default(uuid()) @db.Uuid
  noteId           String    @unique @db.Uuid
  summary          String
  promptTokens     Int?
  completionTokens Int?
  model            String?
  createdAt        DateTime  @default(now()) @db.Timestamptz(6)
  note             TradeNote @relation(fields: [noteId], references: [id])
}

model MarketSnapshot {
  id               String            @id @default(uuid()) @db.Uuid
  symbol           String
  timeframe        String
  close            Decimal           @db.Decimal(18, 8)
  volume           Decimal           @db.Decimal(18, 8)
  indicators       Json
  fetchedAt        DateTime          @db.Timestamptz(6)
  createdAt        DateTime          @default(now()) @db.Timestamptz(6)
  evaluationLogs   EvaluationLog[]   @relation("EvaluationLogSnapshot")
  matchResults     MatchResult[]
  notificationLogs NotificationLog[] @relation("NotificationLogSnapshot")

  @@unique([symbol, timeframe, fetchedAt], map: "uq_snapshot_symbol_timeframe_fetched")
  @@index([symbol, timeframe], map: "idx_snapshot_symbol_timeframe")
}

model MatchResult {
  id                   String                @id @default(uuid()) @db.Uuid
  noteId               String                @db.Uuid
  marketSnapshotId     String                @db.Uuid
  symbol               String
  score                Float
  threshold            Float
  trendMatched         Boolean
  priceRangeMatched    Boolean
  decidedAt            DateTime              @default(now()) @db.Timestamptz(6)
  createdAt            DateTime              @default(now()) @db.Timestamptz(6)
  evaluatedAt          DateTime              @default(now()) @db.Timestamptz(6)
  reasons              Json
  marketSnapshot       MarketSnapshot        @relation(fields: [marketSnapshotId], references: [id])
  note                 TradeNote             @relation(fields: [noteId], references: [id])
  notifications        Notification[]
  notificationSkipLogs NotificationSkipLog[] @relation("NotificationSkipLogMatch")
  orderPresets         OrderPreset[]

  @@unique([noteId, marketSnapshotId], map: "uq_match_note_snapshot")
  @@index([symbol, decidedAt], map: "idx_match_symbol_decided")
}

model Notification {
  id            String             @id @default(uuid()) @db.Uuid
  matchResultId String             @db.Uuid
  title         String
  message       String
  status        NotificationStatus @default(unread)
  sentAt        DateTime           @default(now()) @db.Timestamptz(6)
  readAt        DateTime?          @db.Timestamptz(6)
  createdAt     DateTime           @default(now()) @db.Timestamptz(6)
  matchResult   MatchResult        @relation(fields: [matchResultId], references: [id])

  @@index([status, sentAt], map: "idx_notification_status_sent")
}

model OrderPreset {
  id                String      @id @default(uuid()) @db.Uuid
  matchResultId     String      @db.Uuid
  symbol            String
  side              TradeSide
  suggestedPrice    Decimal     @db.Decimal(18, 8)
  suggestedQuantity Decimal     @db.Decimal(18, 8)
  confidence        Float
  feesEstimate      Decimal?    @db.Decimal(18, 8)
  createdAt         DateTime    @default(now()) @db.Timestamptz(6)
  matchResult       MatchResult @relation(fields: [matchResultId], references: [id])

  @@index([symbol, createdAt], map: "idx_orderpreset_symbol_created")
}

model NotificationLog {
  id               String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  noteId           String                @db.Uuid
  marketSnapshotId String                @db.Uuid
  symbol           String
  score            Float
  channel          String
  status           NotificationLogStatus @default(sent)
  reasonSummary    String
  sentAt           DateTime              @default(now()) @db.Timestamptz(6)
  createdAt        DateTime              @default(now()) @db.Timestamptz(6)
  marketSnapshot   MarketSnapshot        @relation("NotificationLogSnapshot", fields: [marketSnapshotId], references: [id])
  note             TradeNote             @relation("NotificationLogNote", fields: [noteId], references: [id])

  @@unique([noteId, marketSnapshotId, channel], map: "uq_notiflog_note_snapshot_channel")
  @@index([symbol, sentAt], map: "idx_notiflog_symbol_sent")
  @@index([noteId, sentAt], map: "idx_notiflog_note_sent")
}

/// 評価ログ
/// NoteEvaluator.evaluate() の結果を永続化し、
/// ノートの有効性分析（勝率・再現性）の基盤データとなる
model EvaluationLog {
  id               String         @id @default(uuid()) @db.Uuid
  /// ノート ID
  noteId           String         @db.Uuid
  /// 市場スナップショット ID
  marketSnapshotId String         @db.Uuid
  /// シンボル（例: BTCUSDT）
  symbol           String
  /// 時間足（例: 15m, 1h）
  timeframe        String
  /// 類似度スコア（0.0〜1.0）
  similarity       Float
  /// 類似度レベル（strong, medium, weak, none）
  level            String
  /// 発火条件を満たしたか
  triggered        Boolean
  /// 使用したベクトル次元数
  vectorDimension  Int
  /// 使用したインジケーターラベル一覧
  usedIndicators   String[]
  /// 診断情報（noteVector, marketVector 等）
  /// 環境変数 SAVE_EVALUATION_DIAGNOSTICS=true で保存
  diagnostics      Json?
  /// 評価実行日時
  evaluatedAt      DateTime       @db.Timestamptz(6)
  /// レコード作成日時
  createdAt        DateTime       @default(now()) @db.Timestamptz(6)
  marketSnapshot   MarketSnapshot @relation("EvaluationLogSnapshot", fields: [marketSnapshotId], references: [id])
  note             TradeNote      @relation("EvaluationLogNote", fields: [noteId], references: [id])

  @@unique([noteId, marketSnapshotId, timeframe], map: "uq_evallog_note_snapshot_timeframe")
  @@index([noteId, evaluatedAt], map: "idx_evallog_note_evaluated")
  @@index([symbol, evaluatedAt], map: "idx_evallog_symbol_evaluated")
  @@index([triggered, evaluatedAt], map: "idx_evallog_triggered_evaluated")
}

/// ヒストリカルデータプリセット
/// ユーザーがアップロードしたCSVから生成されるOHLCVデータセットのメタ情報
/// シンボル×時間足ごとに1プリセット
model DataPreset {
  id          String   @id @default(uuid()) @db.Uuid
  /// シンボル（例: BTCUSD, USDJPY）
  symbol      String
  /// 時間足（例: 15m, 1h, 4h, 1d）
  timeframe   String
  /// データ開始日時（UTC）
  startDate   DateTime @db.Timestamptz(6)
  /// データ終了日時（UTC）
  endDate     DateTime @db.Timestamptz(6)
  /// レコード数
  recordCount Int
  /// プリセット名（表示用、オプション）
  name        String?
  /// 説明
  description String?
  /// 元ファイル名
  sourceFile  String?
  /// 作成日時
  createdAt   DateTime @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt   DateTime @updatedAt @db.Timestamptz(6)

  @@unique([symbol, timeframe], map: "uq_datapreset_symbol_timeframe")
  @@index([symbol, timeframe], map: "idx_datapreset_symbol_timeframe")
}

/// OHLCV ローソク足データ
/// 将来的に TimescaleDB のハイパーテーブルに変換予定
/// 変換 SQL: SELECT create_hypertable('OHLCVCandle', 'timestamp');
model OHLCVCandle {
  id        String   @id @default(uuid()) @db.Uuid
  /// 銘柄シンボル（例: BTCUSD, EURUSD）
  symbol    String
  /// 時間足（例: 1m, 5m, 15m, 1h, 4h, 1d）
  timeframe String
  /// ローソク足開始時刻（UTC）
  timestamp DateTime @db.Timestamptz(6)
  /// 始値
  open      Decimal  @db.Decimal(18, 8)
  /// 高値
  high      Decimal  @db.Decimal(18, 8)
  /// 安値
  low       Decimal  @db.Decimal(18, 8)
  /// 終値
  close     Decimal  @db.Decimal(18, 8)
  /// 出来高
  volume    Decimal  @db.Decimal(18, 8)
  /// データソース（例: twelvedata, binance）
  source    String?
  /// 作成日時
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  @@unique([symbol, timeframe, timestamp], map: "uq_ohlcv_symbol_timeframe_timestamp")
  @@index([symbol, timeframe, timestamp], map: "idx_ohlcv_symbol_timeframe_timestamp")
  @@index([symbol, timestamp], map: "idx_ohlcv_symbol_timestamp")
}

/// Raw JSON 形式のトレードノート保存
/// 技術スタック選定シート ⑧ に基づくハイブリッド保存
model TradeNoteRaw {
  id        String   @id @default(uuid()) @db.Uuid
  /// 関連するトレードノート ID
  noteId    String   @unique @db.Uuid
  /// Raw JSON データ（将来の再評価・再生成用）
  rawData   Json
  /// スキーマバージョン（破壊的変更対応）
  version   Int      @default(1)
  /// 作成日時
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  @@index([noteId], map: "idx_tradenoteraw_noteid")
}

/// 再評価ジョブ管理
/// 技術スタック選定シート ⑨ に基づく
model RevaluationJob {
  id             String               @id @default(uuid()) @db.Uuid
  /// ジョブタイプ（note_regenerate, feature_recalculate, ai_summary_regenerate）
  jobType        RevaluationJobType
  /// 対象ノート ID（null の場合は全ノート対象）
  targetNoteId   String?              @db.Uuid
  /// 対象銘柄（null の場合は全銘柄対象）
  targetSymbol   String?
  /// ジョブ状態
  status         RevaluationJobStatus @default(pending)
  /// 処理済み件数
  processedCount Int                  @default(0)
  /// 総件数
  totalCount     Int                  @default(0)
  /// エラーメッセージ
  errorMessage   String?
  /// 開始日時
  startedAt      DateTime?            @db.Timestamptz(6)
  /// 完了日時
  completedAt    DateTime?            @db.Timestamptz(6)
  /// 作成日時
  createdAt      DateTime             @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt      DateTime             @updatedAt @db.Timestamptz(6)

  @@index([status, createdAt], map: "idx_revaluationjob_status_created")
  @@index([jobType, status], map: "idx_revaluationjob_type_status")
}

/// バックテスト実行条件
model BacktestRun {
  id                String          @id @default(uuid()) @db.Uuid
  /// 対象ノート ID
  noteId            String          @db.Uuid
  /// 銘柄シンボル
  symbol            String
  /// 時間足（例: 1m, 5m, 15m）
  timeframe         String
  /// バックテスト開始日
  startDate         DateTime        @db.Timestamptz(6)
  /// バックテスト終了日
  endDate           DateTime        @db.Timestamptz(6)
  /// 一致判定しきい値（0.0〜1.0）
  matchThreshold    Float
  /// 利確幅（pips/ポイント）
  takeProfit        Decimal         @db.Decimal(18, 8)
  /// 損切幅（pips/ポイント）
  stopLoss          Decimal         @db.Decimal(18, 8)
  /// 最大保有時間（分）
  maxHoldingMinutes Int             @default(1440)
  /// 取引コスト（スプレッド/手数料）
  tradingCost       Decimal?        @db.Decimal(18, 8)
  /// 実行状態
  status            BacktestStatus  @default(pending)
  /// 作成日時
  createdAt         DateTime        @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt         DateTime        @updatedAt @db.Timestamptz(6)
  events            BacktestEvent[]
  result            BacktestResult?
  note              TradeNote       @relation(fields: [noteId], references: [id])

  @@index([noteId], map: "idx_backtestrun_noteid")
  @@index([status, createdAt], map: "idx_backtestrun_status_created")
}

/// バックテスト集計結果
model BacktestResult {
  id           String      @id @default(uuid()) @db.Uuid
  /// 対応するバックテスト実行 ID
  runId        String      @unique @db.Uuid
  /// セットアップ出現回数
  setupCount   Int
  /// 勝ちトレード数
  winCount     Int
  /// 負けトレード数
  lossCount    Int
  /// タイムアウト数
  timeoutCount Int
  /// 勝率（0.0〜1.0）
  winRate      Float
  /// プロフィットファクター（総利益/総損失）
  profitFactor Float?
  /// 総利益
  totalProfit  Decimal     @db.Decimal(18, 8)
  /// 総損失
  totalLoss    Decimal     @db.Decimal(18, 8)
  /// 平均損益
  averagePnL   Decimal     @db.Decimal(18, 8)
  /// 期待値（平均損益 × 勝率 - 平均損失 × 敗率）
  expectancy   Decimal     @db.Decimal(18, 8)
  /// 最大ドローダウン
  maxDrawdown  Decimal?    @db.Decimal(18, 8)
  /// 計算完了日時
  completedAt  DateTime    @default(now()) @db.Timestamptz(6)
  run          BacktestRun @relation(fields: [runId], references: [id])
}

/// バックテスト個別イベント（各一致場面の結果）
model BacktestEvent {
  id         String          @id @default(uuid()) @db.Uuid
  /// 対応するバックテスト実行 ID
  runId      String          @db.Uuid
  /// エントリー時刻
  entryTime  DateTime        @db.Timestamptz(6)
  /// エントリー価格
  entryPrice Decimal         @db.Decimal(18, 8)
  /// 一致スコア
  matchScore Float
  /// 決済時刻
  exitTime   DateTime?       @db.Timestamptz(6)
  /// 決済価格
  exitPrice  Decimal?        @db.Decimal(18, 8)
  /// 結果（win: 利確到達、loss: 損切到達、timeout: タイムアウト）
  outcome    BacktestOutcome
  /// 損益（pips/ポイント）
  pnl        Decimal?        @db.Decimal(18, 8)
  /// 作成日時
  createdAt  DateTime        @default(now()) @db.Timestamptz(6)
  run        BacktestRun     @relation(fields: [runId], references: [id])

  @@index([runId, entryTime], map: "idx_backtestevent_run_entry")
}

/// Web Push 購読情報
model PushSubscription {
  id           String    @id @default(uuid()) @db.Uuid
  /// Push API エンドポイント URL
  endpoint     String    @unique
  /// 暗号化キー（p256dh）
  p256dh       String
  /// 認証シークレット
  auth         String
  /// 有効フラグ
  active       Boolean   @default(true)
  /// 最終プッシュ送信日時
  lastPushedAt DateTime? @db.Timestamptz(6)
  /// 連続失敗回数（リトライ制御用）
  failureCount Int       @default(0)
  /// 作成日時
  createdAt    DateTime  @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt    DateTime  @updatedAt @db.Timestamptz(6)
  /// ユーザー ID（マルチユーザー対応）
  userId       String    @db.Uuid
  user         User      @relation("UserPushSubscriptions", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, active], map: "idx_pushsub_user_active")
}

/// Push通知送信ログ
model PushLog {
  id             String        @id @default(uuid()) @db.Uuid
  /// 購読 ID
  subscriptionId String        @db.Uuid
  /// 通知 ID（Notification テーブルとの紐付け）
  notificationId String?       @db.Uuid
  /// 送信ステータス
  status         PushLogStatus @default(pending)
  /// エラーメッセージ
  errorMessage   String?
  /// リトライ回数
  retryCount     Int           @default(0)
  /// 送信日時
  sentAt         DateTime?     @db.Timestamptz(6)
  /// 作成日時
  createdAt      DateTime      @default(now()) @db.Timestamptz(6)

  @@index([subscriptionId, createdAt], map: "idx_pushlog_sub_created")
  @@index([status, createdAt], map: "idx_pushlog_status_created")
}

/// マッチング詳細（一致理由の内訳を保存）
model MatchDetail {
  id            String   @id @default(uuid()) @db.Uuid
  /// マッチ結果 ID
  matchResultId String   @db.Uuid
  /// 特徴量名（例: rsi, macd, trend）
  featureName   String
  /// ノート側の値
  noteValue     Float?
  /// スナップショット側の値
  snapshotValue Float?
  /// この特徴量の一致度（0.0〜1.0）
  similarity    Float
  /// 重み付け係数
  weight        Float    @default(1.0)
  /// 寄与度（similarity × weight）
  contribution  Float
  /// 異常値フラグ（Z-score が ±3σ を超えた場合）
  isAnomaly     Boolean  @default(false)
  /// 異常値の場合の詳細
  anomalyDetail String?
  /// 作成日時
  createdAt     DateTime @default(now()) @db.Timestamptz(6)

  @@index([matchResultId], map: "idx_matchdetail_matchresult")
}

/// ストラテジー（売買戦略の定義）
model Strategy {
  id               String                @id @default(uuid()) @db.Uuid
  /// ストラテジー名
  name             String
  /// 説明
  description      String?
  /// 対象シンボル（USDJPY, EURUSD, XAUUSD 等）
  symbol           String
  /// トレード方向（buy/sell）
  side             TradeSide
  /// ステータス
  status           StrategyStatus        @default(draft)
  /// 現在のバージョン ID
  currentVersionId String?               @db.Uuid
  /// タグ（検索・分類用）
  tags             String[]              @default([])
  /// 作成日時
  createdAt        DateTime              @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt        DateTime              @updatedAt @db.Timestamptz(6)
  alert            StrategyAlert?
  backtestRuns     StrategyBacktestRun[]
  strategyNotes    StrategyNote[]
  versions         StrategyVersion[]
  walkForwardRuns  WalkForwardRun[]

  @@index([symbol], map: "idx_strategy_symbol")
  @@index([status], map: "idx_strategy_status")
  @@index([symbol, status], map: "idx_strategy_symbol_status")
}

/// ストラテジーバージョン（変更履歴）
/// 保存時に常に新バージョンを作成し、履歴を保持
model StrategyVersion {
  id              String   @id @default(uuid()) @db.Uuid
  /// 親ストラテジー ID
  strategyId      String   @db.Uuid
  /// バージョン番号（1, 2, 3...）
  versionNumber   Int
  /// エントリー条件（JSON: ConditionGroup）
  entryConditions Json
  /// イグジット設定（JSON: ExitSettings）
  exitSettings    Json
  /// エントリータイミング（next_open 等）
  entryTiming     String   @default("next_open")
  /// 変更理由メモ
  changeNote      String?
  /// 作成日時
  createdAt       DateTime @default(now()) @db.Timestamptz(6)
  strategy        Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  @@unique([strategyId, versionNumber], map: "uq_strategyversion_strategy_version")
  @@index([strategyId], map: "idx_strategyversion_strategyid")
}

/// ストラテジーノート（優位性確認済みセットアップ）
/// バックテストで勝ったセットアップを保存し、パターン検出に活用
model StrategyNote {
  id                String             @id @default(uuid()) @db.Uuid
  /// 親ストラテジー ID
  strategyId        String             @db.Uuid
  /// エントリー時刻（バックテストで検出された時刻）
  entryTime         DateTime           @db.Timestamptz(6)
  /// エントリー価格
  entryPrice        Decimal            @db.Decimal(18, 8)
  /// 一致した条件のスナップショット（JSON）
  conditionSnapshot Json
  /// インジケーター値のスナップショット（JSON）
  indicatorValues   Json
  /// バックテスト結果（win/loss/timeout）
  outcome           BacktestOutcome
  /// 損益
  pnl               Decimal?           @db.Decimal(18, 8)
  /// メモ
  notes             String?
  /// 作成日時
  createdAt         DateTime           @default(now()) @db.Timestamptz(6)
  /// 特徴量ベクトル（類似度検索用）
  /// インジケーター定義の Section 12 に基づいて計算
  featureVector     Float[]            @default([])
  /// ノートの状態（draft/active/archived）
  status            StrategyNoteStatus @default(draft)
  /// タグ（カテゴリ、パターン名など）
  tags              String[]           @default([])
  /// 更新日時
  updatedAt         DateTime           @updatedAt @db.Timestamptz(6)
  strategy          Strategy           @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  @@index([strategyId], map: "idx_strategynote_strategyid")
  @@index([strategyId, outcome], map: "idx_strategynote_strategy_outcome")
  @@index([status], map: "idx_strategynote_status")
  @@index([strategyId, status], map: "idx_strategynote_strategy_status")
}

/// ストラテジーバックテスト実行（ストラテジー条件ベース）
model StrategyBacktestRun {
  id         String                  @id @default(uuid()) @db.Uuid
  /// 対象ストラテジー ID
  strategyId String                  @db.Uuid
  /// 使用したバージョン ID
  versionId  String                  @db.Uuid
  /// 銘柄シンボル
  symbol     String
  /// 時間足（例: 15m, 1h, 4h）
  timeframe  String
  /// バックテスト開始日
  startDate  DateTime                @db.Timestamptz(6)
  /// バックテスト終了日
  endDate    DateTime                @db.Timestamptz(6)
  /// ステージ（stage1: 高速スキャン、stage2: 1分足精密検証）
  stage      String                  @default("stage1")
  /// 実行状態
  status     BacktestStatus          @default(pending)
  /// 作成日時
  createdAt  DateTime                @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt  DateTime                @updatedAt @db.Timestamptz(6)
  events     StrategyBacktestEvent[]
  result     StrategyBacktestResult?
  strategy   Strategy                @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  @@index([strategyId], map: "idx_strategybacktestrun_strategyid")
  @@index([status, createdAt], map: "idx_strategybacktestrun_status_created")
}

/// ストラテジーバックテスト集計結果
model StrategyBacktestResult {
  id           String              @id @default(uuid()) @db.Uuid
  /// 対応するバックテスト実行 ID
  runId        String              @unique @db.Uuid
  /// セットアップ出現回数
  setupCount   Int
  /// 勝ちトレード数
  winCount     Int
  /// 負けトレード数
  lossCount    Int
  /// タイムアウト数
  timeoutCount Int
  /// 勝率（0.0〜1.0）
  winRate      Float
  /// プロフィットファクター（総利益/総損失）
  profitFactor Float?
  /// 総利益
  totalProfit  Decimal             @db.Decimal(18, 8)
  /// 総損失
  totalLoss    Decimal             @db.Decimal(18, 8)
  /// 平均損益
  averagePnL   Decimal             @db.Decimal(18, 8)
  /// 期待値
  expectancy   Decimal             @db.Decimal(18, 8)
  /// 最大ドローダウン
  maxDrawdown  Decimal?            @db.Decimal(18, 8)
  /// 計算完了日時
  completedAt  DateTime            @default(now()) @db.Timestamptz(6)
  run          StrategyBacktestRun @relation(fields: [runId], references: [id], onDelete: Cascade)
}

/// ストラテジーバックテスト個別イベント
model StrategyBacktestEvent {
  id              String              @id @default(uuid()) @db.Uuid
  /// 対応するバックテスト実行 ID
  runId           String              @db.Uuid
  /// エントリー時刻
  entryTime       DateTime            @db.Timestamptz(6)
  /// エントリー価格
  entryPrice      Decimal             @db.Decimal(18, 8)
  /// 条件成立時のインジケーター値（JSON）
  indicatorValues Json?
  /// 決済時刻
  exitTime        DateTime?           @db.Timestamptz(6)
  /// 決済価格
  exitPrice       Decimal?            @db.Decimal(18, 8)
  /// 結果
  outcome         BacktestOutcome
  /// 損益
  pnl             Decimal?            @db.Decimal(18, 8)
  /// 作成日時
  createdAt       DateTime            @default(now()) @db.Timestamptz(6)
  run             StrategyBacktestRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId, entryTime], map: "idx_strategybacktestevent_run_entry")
}

/// ストラテジーアラート設定
/// ストラテジー条件成立時のリアルタイム通知設定
model StrategyAlert {
  id              String             @id @default(uuid()) @db.Uuid
  /// 対象ストラテジー ID
  strategyId      String             @unique @db.Uuid
  /// 有効/無効
  enabled         Boolean            @default(true)
  /// ステータス
  status          AlertStatus        @default(enabled)
  /// クールダウン時間（分）- 同一ストラテジーの連続アラート抑制
  cooldownMinutes Int                @default(60)
  /// 通知チャネル
  channels        AlertChannel[]     @default([in_app])
  /// 最小一致スコア（0.0〜1.0）- この閾値以上で通知
  minMatchScore   Float              @default(0.7)
  /// 最終アラート発火日時
  lastTriggeredAt DateTime?          @db.Timestamptz(6)
  /// 作成日時
  createdAt       DateTime           @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt       DateTime           @updatedAt @db.Timestamptz(6)
  strategy        Strategy           @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  logs            StrategyAlertLog[]

  @@index([enabled, status], map: "idx_strategyalert_enabled_status")
}

/// ストラテジーアラート発火履歴
model StrategyAlertLog {
  id              String        @id @default(uuid()) @db.Uuid
  /// 対象アラート ID
  alertId         String        @db.Uuid
  /// 一致スコア
  matchScore      Float
  /// 条件成立時のインジケーター値（JSON）
  indicatorValues Json
  /// 通知先チャネル
  channel         AlertChannel
  /// 通知成功/失敗
  success         Boolean
  /// エラーメッセージ（失敗時）
  errorMessage    String?
  /// 発火日時
  triggeredAt     DateTime      @default(now()) @db.Timestamptz(6)
  alert           StrategyAlert @relation(fields: [alertId], references: [id], onDelete: Cascade)

  @@index([alertId, triggeredAt], map: "idx_strategyalertlog_alert_triggered")
}

/// ウォークフォワードテスト実行
model WalkForwardRun {
  id              String             @id @default(uuid()) @db.Uuid
  /// 対象ストラテジー ID
  strategyId      String             @db.Uuid
  /// 使用したバージョン ID
  versionId       String             @db.Uuid
  /// テスト種別
  type            WalkForwardType    @default(fixed_split)
  /// 分割数（固定分割の場合）
  splitCount      Int                @default(4)
  /// In-Sample期間（日数）
  inSampleDays    Int
  /// Out-of-Sample期間（日数）
  outOfSampleDays Int
  /// テスト開始日
  startDate       DateTime           @db.Timestamptz(6)
  /// テスト終了日
  endDate         DateTime           @db.Timestamptz(6)
  /// 時間足
  timeframe       String             @default("1h")
  /// 実行状態
  status          BacktestStatus     @default(pending)
  /// 過学習スコア（0.0〜1.0、低いほど良い）
  /// In-Sample勝率とOut-of-Sample勝率の乖離で算出
  overfitScore    Float?
  /// 総合判定（過学習の疑いあり/なし）
  overfitWarning  Boolean?
  /// 作成日時
  createdAt       DateTime           @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt       DateTime           @updatedAt @db.Timestamptz(6)
  strategy        Strategy           @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  splits          WalkForwardSplit[]

  @@index([strategyId], map: "idx_walkforwardrun_strategyid")
  @@index([status, createdAt], map: "idx_walkforwardrun_status_created")
}

/// ウォークフォワードテスト分割結果
model WalkForwardSplit {
  id                      String         @id @default(uuid()) @db.Uuid
  /// 対応するウォークフォワード実行 ID
  runId                   String         @db.Uuid
  /// 分割番号（1, 2, 3...）
  splitNumber             Int
  /// In-Sample開始日
  inSampleStart           DateTime       @db.Timestamptz(6)
  /// In-Sample終了日
  inSampleEnd             DateTime       @db.Timestamptz(6)
  /// Out-of-Sample開始日
  outOfSampleStart        DateTime       @db.Timestamptz(6)
  /// Out-of-Sample終了日
  outOfSampleEnd          DateTime       @db.Timestamptz(6)
  /// In-Sample勝率
  inSampleWinRate         Float
  /// In-Sampleトレード数
  inSampleTradeCount      Int
  /// In-SampleプロフィットファクターInt
  inSampleProfitFactor    Float?
  /// Out-of-Sample勝率
  outOfSampleWinRate      Float
  /// Out-of-Sampleトレード数
  outOfSampleTradeCount   Int
  /// Out-of-Sampleプロフィットファクター
  outOfSampleProfitFactor Float?
  /// 勝率の乖離（In - Out）
  winRateDiff             Float
  /// 作成日時
  createdAt               DateTime       @default(now()) @db.Timestamptz(6)
  run                     WalkForwardRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@unique([runId, splitNumber], map: "uq_walkforwardsplit_run_number")
  @@index([runId], map: "idx_walkforwardsplit_runid")
}

/// ユーザーロール
enum UserRole {
  /// 一般ユーザー
  user
  /// 管理者
  admin
}

/// ノートの承認状態
enum NoteStatus {
  draft
  active
  archived
}

enum TradeSide {
  buy
  sell
}

enum NotificationStatus {
  unread
  read
  deleted
}

enum NotificationLogStatus {
  sent
  skipped
  failed
}

enum RevaluationJobType {
  note_regenerate
  feature_recalculate
  ai_summary_regenerate
  full_reprocess
}

enum RevaluationJobStatus {
  pending
  running
  completed
  failed
  cancelled
}

enum BacktestStatus {
  pending
  running
  completed
  failed
}

enum BacktestOutcome {
  win
  loss
  timeout
}

/// ストラテジーノートの状態
enum StrategyNoteStatus {
  /// 下書き（作成直後）
  draft
  /// アクティブ（類似度検索対象）
  active
  /// アーカイブ（検索対象外）
  archived
}

enum PushLogStatus {
  pending
  sent
  failed
  retrying
}

/// ストラテジーステータス
enum StrategyStatus {
  draft
  active
  archived
}

/// アラート通知チャネル
enum AlertChannel {
  /// アプリ内通知
  in_app
  /// Web Push通知
  web_push
}

/// アラートステータス
enum AlertStatus {
  /// 有効
  enabled
  /// 無効
  disabled
  /// 一時停止（クールダウン中）
  paused
}

/// ウォークフォワードテスト種別
enum WalkForwardType {
  /// 固定分割（N分割）
  fixed_split
  /// ローリングウィンドウ（将来拡張用）
  rolling_window
}

// ============================================================
// フェーズ8: 複数ノート運用UX - 同時ヒット制御
// ============================================================

/// 通知バッチ設定（同時ヒット制御のグローバル設定）
/// システム全体で1レコードのみ保持（シングルトン）
model NotificationBatchConfig {
  id               String   @id @default(uuid()) @db.Uuid
  /// 同時に送信する最大通知数（デフォルト3）
  maxSimultaneous  Int      @default(3)
  /// シンボル別にグループ化するか（trueの場合、シンボルごとにmaxSimultaneous適用）
  groupBySymbol    Boolean  @default(true)
  /// クールダウン時間（分）- 同一ノートへの連続通知を抑制
  cooldownMinutes  Int      @default(15)
  /// 作成日時
  createdAt        DateTime @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt        DateTime @updatedAt @db.Timestamptz(6)
}

/// 通知スキップログ（同時ヒット制御でスキップされた通知の記録）
/// デバッグ・分析用。なぜ通知されなかったかを追跡可能にする
model NotificationSkipLog {
  id             String               @id @default(uuid()) @db.Uuid
  /// スキップされた TradeNote ID
  noteId         String               @db.Uuid
  /// マッチ結果 ID（任意）
  matchResultId  String?              @db.Uuid
  /// スキップ理由
  reason         NotificationSkipReason
  /// 詳細情報（JSON形式で任意のメタデータ）
  details        Json?
  /// スキップ発生日時
  skippedAt      DateTime             @default(now()) @db.Timestamptz(6)

  note           TradeNote            @relation("NotificationSkipLogNote", fields: [noteId], references: [id])
  matchResult    MatchResult?         @relation("NotificationSkipLogMatch", fields: [matchResultId], references: [id])

  @@index([noteId], map: "idx_notification_skip_note")
  @@index([skippedAt], map: "idx_notification_skip_at")
  @@index([reason], map: "idx_notification_skip_reason")
}

/// 通知スキップ理由
enum NotificationSkipReason {
  /// 同時ヒット数上限超過（優先度が低いためスキップ）
  max_simultaneous_exceeded
  /// クールダウン中（同一ノートへの連続通知抑制）
  cooldown_active
  /// ノートが無効化されている
  note_disabled
  /// ノートが一時停止中
  note_paused
  /// 優先度が低い（同一シンボル内で優先度負け）
  lower_priority
}

