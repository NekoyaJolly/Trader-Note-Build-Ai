# TraderAssist MVP｜意図の棚卸し・フェーズ別実装提案（補完版）＋実装Agent指示（レビュー反映）

## 0. 意図理解（あなたが実現したい未来の解像度）

結論として、意図は正確に伝わっています。私の理解は次の一文に集約されます。

> **「過去の自分のトレードを“定義済みの知識資産（ノート）”へ変換し、現在市場と照合して“再現可能な優位性”を通知・発注導線で即実行できる状態にする」**

このアプリは「記録」ではなく、
- 過去（トレード）→ **定義（特徴量・文脈・理由）**
- 現在（市場）→ **スナップショット**
- 両者を照合 → **一致の検出**
- 検出結果を **納得可能な説明** と **実行導線** に変換

までを一気通貫で担います。

---

## 1. 現状の棚卸し（FS＋DBハイブリッドの「今」）

### 1.1 何がFS（ファイル）にあり、何がDBにあるか
現状は、ざっくり下記の分担になっています。

- **FSに寄っているもの**
  - トレードノート本体（JSON）
  - 通知本体（既読状態含む）
  - CSV配置（data/trades）

- **DBに寄っているもの**
  - マッチング結果の永続化（MatchResult）
  - 通知の抑止・冪等性・クールダウン・重複抑制のログ（NotificationLog）

### 1.2 なぜ今ハイブリッドなのか（合理性）
「今」ハイブリッドにしているのは、MVP段階としては合理性があります。

- **FSが強い領域**
  - ノートは（将来的に）大きなJSONになりやすい（指標・区間・根拠・生成テキスト）
  - スキーマ変更が早い段階で多発する
  - まず動かして価値検証しやすい

- **DBが強い領域**
  - 冪等性、クールダウン、重複抑止など「一貫性のある運用ロジック」が必要
  - 集計/検索/監査（いつ・何が・なぜ通知されたか）を行いたい
  - 同時実行や将来のスケールを見据えるとFSは事故りやすい

### 1.3 ハイブリッドの「将来の落とし穴」
ただし、ハイブリッドは長期運用に入ると「整合性維持コスト」が上がります。

- FSとDBで「真実の所在」が分裂する
- 再計算/再通知/再生成の境界が曖昧だと事故る
- バックアップ、マイグレーション、監査のやり方が二重化する

> よって、MVP検証が終わった段階で「どこを真実にするか」を一度決め直すのが良いです。

---

## 2. ドメイン定義（このアプリが扱う“定義済み情報”の設計）

あなたの「トレードを定義づける」を、実装可能な単位へ分解すると以下になります。

### 2.1 コアエンティティ
- **Trade（ユーザートレード）**: 入力の元（CSV/取引所）。
- **MarketSnapshot（市場スナップショット）**: ある時刻・ある時間足・ある銘柄の市場状態。
- **IndicatorSet（指標集合）**: Snapshotに対して計算された指標の集合（RSI, MACD, BB, SMA…）。
- **TradeDefinition（定義）**: Trade + Snapshot + IndicatorSet + ルール派生情報（trend等）から作る“特徴量”。
- **TradeNote（ノート）**: TradeDefinition + 文章（AI要約） + ユーザー承認状態。

### 2.2 ノートのライフサイクル（重要）
- **draft**: AI生成直後。ユーザーが「承認/非承認/編集」可能。
- **approved**: マッチング対象。検索・通知・バックテスト対象。
- **rejected**: アーカイブ扱い（学習対象にするかは将来決める）。

### 2.3 「検索可能」とは何か（最低要件）
- 一覧表示（フィルタ：銘柄、時間足、売買、期間）
- フルテキスト検索（AI要約やユーザー追記）
- “一致条件”での検索（例：RSI帯、トレンド一致、価格帯）

---

## 3. 市場データ設計（通常運用とバックテストで取得先を分ける）

あなたの方針は合理的です。

- **通常運用（M15以上）**
  - 低頻度・安定性重視
  - 取得コストを抑える（API制限・課金）
  - “通知の納得性”が目的（tick精度は不要）

- **バックテスト（M1以上）**
  - 精度重視
  - 取得先を増やしてもよい（MVP後に差し替えやすく）
  - データ欠損・タイムゾーン・サマータイムの補正が必要

### 3.1 データ正規化の原則
- タイムゾーンは必ず **UTCに正規化**
- 時間足の終値確定時刻（candle close）基準を統一
- 指標は「未来データ」を使わない（look-ahead bias対策）

---

## 4. フェーズ別 実装提案（冗長OK：やることを具体化）

---

## 4.1 今回の意思決定（確定・運用前提）

あなたの判断を、このドキュメント上の“確定仕様”として固定します。以降の実装・Docs・テストは必ずこの方針に従います。

### 決定事項一覧
1) **/api/daily-status は実装する（UIで使用するため）**
   - ステータスの最低要件: `schedulerRunning`, `cronEnabled`, `lastRunAt`, `lastError`, `queueDepth(任意)`
   - UIは「稼働・停止・直近実行・直近エラー」が一目で分かること。

2) **Docs と実装の整合は「まず Docs を実装に寄せて止血」→「OpenAPI をSSOT化してズレを防止」**
   - 止血フェーズ: docs/API.md と README を現実装へ同期
   - 恒久対策: OpenAPI を単一の真実として運用（自動生成Docs／契約テストで回帰防止）

3) **発注支援導線は noteId に統一（UIリンクもAPIも noteId を唯一のキーにする）**
   - `/orders/preset?noteId=...` を正とし、symbol/side は表示用の補助として扱う。

4) **/api/notifications/logs はデフォルト全件（ページング必須）、失敗のみは `status=failed`**
   - “フィルタ無し＝全件”の直感性を優先。

5) **ストレージ戦略は DB中心＋オブジェクト（大容量はオブジェクト、検索・整合はDB）へ寄せる**
   - MVPで残っているFS依存は段階的に置換可能な形へ（path/url + hash をDBに保持）。

6) **重要状態遷移（取込/定義/承認/通知）は append-only の監査ログを持つ（全イベントソーシングはしない）**
   - 目的: 再現性と原因追跡。

7) **契約のズレを恒久的に防ぐため、OpenAPI＋契約テスト（CDC）をCIに組み込む**
   - まずは主要エンドポイント（import, notes, matching, notifications, orders）から。

---


以下は「いまの実装状況（MVP骨格あり）」を前提に、価値の立ち上がりが早い順で組んだフェーズです。

### Phase 0 — “導線が切れている箇所”をゼロにする（最優先）
目的: 「通知→発注支援」などMVPの主要導線が 404 / 仕様不一致で止まらない状態にする。

- Done条件
  - 通知詳細から発注支援UIへ遷移できる（404がない）
  - API docs と実装が一致し、外部から叩いても誤解が起きない

- 作業（レビュー結果ベース）
  1) 発注支援 /orders/preset の統一（UI追加 or リンク修正）
  2) /api/notifications/check を「Docに寄せる」か「Docを実装に寄せる」か決めて固定
  3) README / docs/API.md のレスポンス例（matching/history, import/csv 等）を同期
  4) Docsに未記載のエンドポイント（upload-text, approve 等）を追記
  5) Port/CORS/CRON_ENABLED の説明をDocsへ反映

---

### Phase 1 — トレード取込の「定義化」パイプラインを固定する
目的: CSVを入れたら、以降の全機能の共通資産（TradeDefinition/TradeNote）まで一気に作れる。

- 入力
  - CSV（timestamp, symbol, side, price, quantity, fee, exchange…）

- パイプライン（推奨）
  1) CSV parse → バリデーション（欠損・型・TZ）
  2) Trade正規化（UTC, 通貨ペア/銘柄正規化、side正規化）
  3) 市場データ取得（取引時刻±window、時間足）
  4) 指標計算（ユーザー選択の指標セット）
  5) TradeDefinition生成（特徴量＋補助カテゴリ）
  6) AI要約生成（テンプレ＋制約で安定化）
  7) TradeNote（draft）保存

- Done条件
  - 取込→ノート生成が再現性高く動く
  - エラーは「ユーザーに直せる言葉」で返る

---

### Phase 2 — ノート承認フローを「後戻りできる」設計にする
目的: AI生成は必ず揺れる。ユーザーが承認・編集・非承認を行える導線を確実にする。

- UI
  - ノート詳細で
    - 承認
    - 非承認
    - 編集（文章・タグ・任意フィールド）

- API
  - approve / reject / update を明確に分ける

- 永続化
  - 「ノート本体」と「承認状態」を分ける
  - 承認済みのみマッチング対象

- Done条件
  - 承認済みノートのみが照合に使われる

---

### Phase 3 — リアルタイム照合の“説明責任”を完成させる
目的: 「当たる」より「納得できる」。なぜ一致したのかを可視化する。

- スナップショット
  - M15以上で定期取得
  - 指標計算（ノートと同じ定義で）

- マッチング
  - feature vector の健全性チェック（NaN/Infinity）
  - ルールベース補正（trend一致、価格帯一致など）
  - しきい値判定

- UI
  - 通知詳細に
    - 一致スコア内訳
    - 参照ノートの要点
    - スナップショット指標

- Done条件
  - 一致理由を説明できる（ブラックボックス化しない）

---

### Phase 4 — 通知（in-app + push）を「運用できる」状態へ
目的: 重要通知が届き、無駄通知は抑止され、履歴が追える。

- Push通知（Web/PWA想定）
  - 購読（PushSubscription）の登録
  - サーバ側送信
  - 失敗ログとリトライ方針

- 抑止
  - noteId × snapshotId × channel の冪等性
  - クールダウン
  - 重複抑止

- Done条件
  - pushが安定し、抑止が効き、ログで追える

---

### Phase 5 — バックテストを「ノート詳細ページから」実行できるようにする（あなたの追加要件）
目的: ノートが“優位性の証拠”として機能する。ワンタップで検証できる。

#### 5.1 UI導線（ノート詳細→バックテスト）
- ノート詳細に「バックテスト」セクション
  - 期間選択（例：直近3ヶ月/6ヶ月/カスタム）
  - 時間足（M1以上）
  - しきい値（ノート一致%）
  - PF/LC（利確/損切）設定
  - 取引コスト（スプレッド/手数料）

#### 5.2 バックテスト定義（あなたの要件を実装仕様へ）
- 「指定期間内で、ノートに **X%以上一致** する場面が何回出るか」
- その各場面に対し
  - エントリー時刻 = 一致したスナップショットの時刻
  - その後の価格推移で PF（利確） or LC（損切）に到達したか
  - 到達しなければタイムアウト（期間末 or 最大保有）

#### 5.3 主要指標（最低限）
- 出現回数（セットアップ回数）
- 勝率
- PF（Profit Factor）
- 平均損益、期待値
- 最大ドローダウン（可能なら）

#### 5.4 実装上の論点（事故防止）
- 時系列のズレ（candle closeで評価するか、openで評価するか）
- “一致判定に使った足”と“エントリー足”の整合
- look-ahead bias（未来の確定情報を一致判定に使っていないか）

#### 5.5 永続化
- BacktestRun（入力条件）
- BacktestResult（集計結果）
- BacktestEvents（各一致場面の結果、必要なら）

- Done条件
  - ノート詳細からバックテストが実行できる
  - 結果が一目で分かる（優位性が可視化）

---

### Phase 6 — 「5タッチ以内で注文パネルへ」到達できる導線を固める
目的: 通知→実行の摩擦を最小化する。

- 通知詳細
  - 注文プリセット（side/price/qty）
  - “注文確認”ダイアログ

- クリック数を削る方法
  - 通知カードに「注文」ボタン（直接遷移）
  - noteIdベースのプリセット生成で情報欠損を防ぐ

- Done条件
  - 通知確認から注文確認まで5タッチ以内

---

### Phase 7 — 検索性・再利用性を一段上げる（MVP後）
目的: ノートが増えても“未来の自分”が迷わない。

- タグ・フィルタ
- 類似ノート検索
- ノートのクラスター（同系統のトレードを束ねる）

---

### Phase 8 — ストレージ戦略の再決定（MVP→運用の境界）
目的: ハイブリッドの運用事故を未然に潰す。

選択肢（推奨順）
1) **DB中心 + オブジェクトストレージ（大容量）**
2) **DBのみ（JSONB活用）**
3) **FS中心（現状維持）**（運用は難易度が上がる）

決めること
- “真実の所在”をどこに置くか
- バックアップ/リストアの単位
- マイグレーション戦略

---

## 5. 実装Agentに渡す「完全版プロンプト」（縦割りレビュー反映）

> このセクションは、そのまま実装Agentに貼り付けて使用することを想定しています。

### 5.1 目的
TraderAssist MVP を「主要導線が切れていない」「Docsと実装が矛盾しない」状態へ修正し、次フェーズ（バックテスト導線）実装の土台を固める。

### 5.2 実行ルール（厳守）
- 変更は **最小手数** を優先する（方針変更・大規模リファクタは禁止）
- 変更したら必ず
  - API docs / README を同期
  - 型（TypeScript）とテストを通す
  - エンドポイントのレスポンス例も更新
- UI→API→永続化（FS/DB）の縦割り導線が、実際に動くことを確認する
- 「Docに寄せる」か「実装に寄せる」か、各項目で一度決めたら一貫させる

### 5.3 取り込みインプット（レビュー結果）
- review-report_2025-12-30.md に記載の High/Medium を優先順で解消する。
- implementation-matrix.md の ⚠️/❌ を ✅ へ近づける。

### 5.4 タスク（優先順）

#### Task A（High-1）: 発注支援導線を復旧する（/orders/preset）
- 現状: 通知詳細が /orders/preset?symbol=...&side=... に遷移するが、フロントに該当ページが無い。
- 目標: 通知詳細 → 発注支援UI が 404 にならない。
- 実装方針（どちらかに統一）
  - A案: `src/frontend/app/orders/preset/page.tsx` を追加し、クエリから注文確認APIへ接続
  - B案: 通知詳細のリンクを noteId ベースに変更し、`GET /api/orders/preset/:noteId` と揃える
- Done: 通知詳細から注文UIに到達し、注文確認まで動く。

#### Task B（High-2）: /api/notifications/check の仕様を固定する
- 現状: Docsは matchResultId/channel を受け取るが、実装は無視して再マッチングしている。
- 方針候補
  - Docを実装に寄せる（matchResultIdは未使用、channel固定等を明記）
  - 実装をDocに寄せる（matchResultId指定で評価、channelも反映）
- Done: Docs/API.md/README と実装が一致し、クライアントが誤実装しない。

#### Task C（Medium）: Docsと実装の不一致をまとめて解消
- /api/matching/history のレスポンス例
- /api/trades/import/csv のレスポンス例（notes vs noteIds）
- Docs未記載のエンドポイント追記（upload-text, approve）
- /api/notifications/logs のデフォルト動作（失敗ログのみ）を明記 or 変更
- Done: README と docs/API.md が現実装の正確な説明になる。

#### Task D（横断）: Port/CORS/CRON_ENABLED の説明を正す
- Docsが 3000/3001 前提で残っている箇所を現状に合わせる。
- Done: ローカル起動手順が1回で通る。

### 5.5 検証（最低限やる）
- ローカル起動
  - backend
  - frontend
- 主要導線
  - 通知一覧 → 通知詳細 → 発注支援（404なし）
  - ノート一覧 → ノート詳細 → 承認
- API
  - import/csv
  - trades/notes
  - matching/check
  - matching/history
  - notifications（list/read）
  - notifications/check

### 5.6 成果物
- 実装修正（UI/Backend）
- README / docs/API.md / src/frontend/README.md の更新
- 必要なら implementation-matrix の判定更新（✅/⚠️/❌）

---

## 6. 次フェーズへの布石（バックテスト導線の実装に向けて）

Phase 0 が完了して導線が復旧したら、次は「ノート詳細からバックテスト」を最短で出すために、最低限以下を先に決めると実装がブレません。

- バックテストの一致判定は
  - candle open 基準か
  - candle close 基準か
- 価格到達判定は
  - high/low を使うか
  - close のみか
- 最大保有時間
- コストモデル（スプレッド/手数料）

これらは「精密さ」ではなく、「再現性」と「納得性」を優先して決めるのが、このMVPには適します。

