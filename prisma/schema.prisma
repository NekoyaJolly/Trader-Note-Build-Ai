generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Trade {
  id        String     @id @default(uuid()) @db.Uuid
  timestamp DateTime   @db.Timestamptz(6)
  symbol    String
  side      TradeSide
  price     Decimal    @db.Decimal(18, 8)
  quantity  Decimal    @db.Decimal(18, 8)
  fee       Decimal?   @db.Decimal(18, 8)
  exchange  String?
  createdAt DateTime   @default(now()) @db.Timestamptz(6)
  updatedAt DateTime   @updatedAt @db.Timestamptz(6)
  note      TradeNote?

  @@index([symbol, timestamp], map: "idx_trade_symbol_timestamp")
}

model TradeNote {
  id               String            @id @default(uuid()) @db.Uuid
  tradeId          String            @unique @db.Uuid
  symbol           String
  entryPrice       Decimal           @db.Decimal(18, 8)
  side             TradeSide
  indicators       Json?
  featureVector    Float[]
  timeframe        String?
  createdAt        DateTime          @default(now()) @db.Timestamptz(6)
  updatedAt        DateTime          @updatedAt @db.Timestamptz(6)
  /// 承認日時
  approvedAt       DateTime?         @db.Timestamptz(6)
  /// 最終編集日時
  lastEditedAt     DateTime?         @db.Timestamptz(6)
  /// トレード時点の市場コンテキスト（JSON: trend, calculatedIndicators等）
  marketContext    Json?
  /// 非承認日時
  rejectedAt       DateTime?         @db.Timestamptz(6)
  /// 承認状態（draft: 下書き、approved: 承認済み、rejected: 非承認）
  status           NoteStatus        @default(draft)
  /// タグ（検索用）
  tags             String[]          @default([])
  /// ユーザーによる追記コメント
  userNotes        String?
  aiSummary        AISummary?
  backtestRuns     BacktestRun[]
  matchResult      MatchResult[]
  notificationLogs NotificationLog[] @relation("NotificationLogNote")
  trade            Trade             @relation(fields: [tradeId], references: [id])

  @@index([symbol], map: "idx_tradenote_symbol")
  @@index([status], map: "idx_tradenote_status")
  @@index([symbol, status], map: "idx_tradenote_symbol_status")
}

model AISummary {
  id               String    @id @default(uuid()) @db.Uuid
  noteId           String    @unique @db.Uuid
  summary          String
  promptTokens     Int?
  completionTokens Int?
  model            String?
  createdAt        DateTime  @default(now()) @db.Timestamptz(6)
  note             TradeNote @relation(fields: [noteId], references: [id])
}

model MarketSnapshot {
  id               String            @id @default(uuid()) @db.Uuid
  symbol           String
  timeframe        String
  close            Decimal           @db.Decimal(18, 8)
  volume           Decimal           @db.Decimal(18, 8)
  indicators       Json
  fetchedAt        DateTime          @db.Timestamptz(6)
  createdAt        DateTime          @default(now()) @db.Timestamptz(6)
  matchResults     MatchResult[]
  notificationLogs NotificationLog[] @relation("NotificationLogSnapshot")

  @@unique([symbol, timeframe, fetchedAt], map: "uq_snapshot_symbol_timeframe_fetched")
  @@index([symbol, timeframe], map: "idx_snapshot_symbol_timeframe")
}

model MatchResult {
  id                String         @id @default(uuid()) @db.Uuid
  noteId            String         @db.Uuid
  marketSnapshotId  String         @db.Uuid
  symbol            String
  score             Float
  threshold         Float
  trendMatched      Boolean
  priceRangeMatched Boolean
  decidedAt         DateTime       @default(now()) @db.Timestamptz(6)
  createdAt         DateTime       @default(now()) @db.Timestamptz(6)
  evaluatedAt       DateTime       @default(now()) @db.Timestamptz(6)
  reasons           Json
  marketSnapshot    MarketSnapshot @relation(fields: [marketSnapshotId], references: [id])
  note              TradeNote      @relation(fields: [noteId], references: [id])
  notifications     Notification[]
  orderPresets      OrderPreset[]

  @@unique([noteId, marketSnapshotId], map: "uq_match_note_snapshot")
  @@index([symbol, decidedAt], map: "idx_match_symbol_decided")
}

model Notification {
  id            String             @id @default(uuid()) @db.Uuid
  matchResultId String             @db.Uuid
  title         String
  message       String
  status        NotificationStatus @default(unread)
  sentAt        DateTime           @default(now()) @db.Timestamptz(6)
  readAt        DateTime?          @db.Timestamptz(6)
  createdAt     DateTime           @default(now()) @db.Timestamptz(6)
  matchResult   MatchResult        @relation(fields: [matchResultId], references: [id])

  @@index([status, sentAt], map: "idx_notification_status_sent")
}

model OrderPreset {
  id                String      @id @default(uuid()) @db.Uuid
  matchResultId     String      @db.Uuid
  symbol            String
  side              TradeSide
  suggestedPrice    Decimal     @db.Decimal(18, 8)
  suggestedQuantity Decimal     @db.Decimal(18, 8)
  confidence        Float
  feesEstimate      Decimal?    @db.Decimal(18, 8)
  createdAt         DateTime    @default(now()) @db.Timestamptz(6)
  matchResult       MatchResult @relation(fields: [matchResultId], references: [id])

  @@index([symbol, createdAt], map: "idx_orderpreset_symbol_created")
}

model NotificationLog {
  id               String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  noteId           String                @db.Uuid
  marketSnapshotId String                @db.Uuid
  symbol           String
  score            Float
  channel          String
  status           NotificationLogStatus @default(sent)
  reasonSummary    String
  sentAt           DateTime              @default(now()) @db.Timestamptz(6)
  createdAt        DateTime              @default(now()) @db.Timestamptz(6)
  marketSnapshot   MarketSnapshot        @relation("NotificationLogSnapshot", fields: [marketSnapshotId], references: [id])
  note             TradeNote             @relation("NotificationLogNote", fields: [noteId], references: [id])

  @@unique([noteId, marketSnapshotId, channel], map: "uq_notiflog_note_snapshot_channel")
  @@index([symbol, sentAt], map: "idx_notiflog_symbol_sent")
  @@index([noteId, sentAt], map: "idx_notiflog_note_sent")
}

/// OHLCV ローソク足データ
/// 将来的に TimescaleDB のハイパーテーブルに変換予定
/// 変換 SQL: SELECT create_hypertable('OHLCVCandle', 'timestamp');
model OHLCVCandle {
  id        String   @id @default(uuid()) @db.Uuid
  /// 銘柄シンボル（例: BTCUSD, EURUSD）
  symbol    String
  /// 時間足（例: 1m, 5m, 15m, 1h, 4h, 1d）
  timeframe String
  /// ローソク足開始時刻（UTC）
  timestamp DateTime @db.Timestamptz(6)
  /// 始値
  open      Decimal  @db.Decimal(18, 8)
  /// 高値
  high      Decimal  @db.Decimal(18, 8)
  /// 安値
  low       Decimal  @db.Decimal(18, 8)
  /// 終値
  close     Decimal  @db.Decimal(18, 8)
  /// 出来高
  volume    Decimal  @db.Decimal(18, 8)
  /// データソース（例: twelvedata, binance）
  source    String?
  /// 作成日時
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  @@unique([symbol, timeframe, timestamp], map: "uq_ohlcv_symbol_timeframe_timestamp")
  @@index([symbol, timeframe, timestamp], map: "idx_ohlcv_symbol_timeframe_timestamp")
  @@index([symbol, timestamp], map: "idx_ohlcv_symbol_timestamp")
}

/// Raw JSON 形式のトレードノート保存
/// 技術スタック選定シート ⑧ に基づくハイブリッド保存
model TradeNoteRaw {
  id        String   @id @default(uuid()) @db.Uuid
  /// 関連するトレードノート ID
  noteId    String   @unique @db.Uuid
  /// Raw JSON データ（将来の再評価・再生成用）
  rawData   Json
  /// スキーマバージョン（破壊的変更対応）
  version   Int      @default(1)
  /// 作成日時
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  @@index([noteId], map: "idx_tradenoteraw_noteid")
}

/// 再評価ジョブ管理
/// 技術スタック選定シート ⑨ に基づく
model RevaluationJob {
  id             String               @id @default(uuid()) @db.Uuid
  /// ジョブタイプ（note_regenerate, feature_recalculate, ai_summary_regenerate）
  jobType        RevaluationJobType
  /// 対象ノート ID（null の場合は全ノート対象）
  targetNoteId   String?              @db.Uuid
  /// 対象銘柄（null の場合は全銘柄対象）
  targetSymbol   String?
  /// ジョブ状態
  status         RevaluationJobStatus @default(pending)
  /// 処理済み件数
  processedCount Int                  @default(0)
  /// 総件数
  totalCount     Int                  @default(0)
  /// エラーメッセージ
  errorMessage   String?
  /// 開始日時
  startedAt      DateTime?            @db.Timestamptz(6)
  /// 完了日時
  completedAt    DateTime?            @db.Timestamptz(6)
  /// 作成日時
  createdAt      DateTime             @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt      DateTime             @updatedAt @db.Timestamptz(6)

  @@index([status, createdAt], map: "idx_revaluationjob_status_created")
  @@index([jobType, status], map: "idx_revaluationjob_type_status")
}

/// バックテスト実行条件
model BacktestRun {
  id                String          @id @default(uuid()) @db.Uuid
  /// 対象ノート ID
  noteId            String          @db.Uuid
  /// 銘柄シンボル
  symbol            String
  /// 時間足（例: 1m, 5m, 15m）
  timeframe         String
  /// バックテスト開始日
  startDate         DateTime        @db.Timestamptz(6)
  /// バックテスト終了日
  endDate           DateTime        @db.Timestamptz(6)
  /// 一致判定しきい値（0.0〜1.0）
  matchThreshold    Float
  /// 利確幅（pips/ポイント）
  takeProfit        Decimal         @db.Decimal(18, 8)
  /// 損切幅（pips/ポイント）
  stopLoss          Decimal         @db.Decimal(18, 8)
  /// 最大保有時間（分）
  maxHoldingMinutes Int             @default(1440)
  /// 取引コスト（スプレッド/手数料）
  tradingCost       Decimal?        @db.Decimal(18, 8)
  /// 実行状態
  status            BacktestStatus  @default(pending)
  /// 作成日時
  createdAt         DateTime        @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt         DateTime        @updatedAt @db.Timestamptz(6)
  events            BacktestEvent[]
  result            BacktestResult?
  note              TradeNote       @relation(fields: [noteId], references: [id])

  @@index([noteId], map: "idx_backtestrun_noteid")
  @@index([status, createdAt], map: "idx_backtestrun_status_created")
}

/// バックテスト集計結果
model BacktestResult {
  id           String      @id @default(uuid()) @db.Uuid
  /// 対応するバックテスト実行 ID
  runId        String      @unique @db.Uuid
  /// セットアップ出現回数
  setupCount   Int
  /// 勝ちトレード数
  winCount     Int
  /// 負けトレード数
  lossCount    Int
  /// タイムアウト数
  timeoutCount Int
  /// 勝率（0.0〜1.0）
  winRate      Float
  /// プロフィットファクター（総利益/総損失）
  profitFactor Float?
  /// 総利益
  totalProfit  Decimal     @db.Decimal(18, 8)
  /// 総損失
  totalLoss    Decimal     @db.Decimal(18, 8)
  /// 平均損益
  averagePnL   Decimal     @db.Decimal(18, 8)
  /// 期待値（平均損益 × 勝率 - 平均損失 × 敗率）
  expectancy   Decimal     @db.Decimal(18, 8)
  /// 最大ドローダウン
  maxDrawdown  Decimal?    @db.Decimal(18, 8)
  /// 計算完了日時
  completedAt  DateTime    @default(now()) @db.Timestamptz(6)
  run          BacktestRun @relation(fields: [runId], references: [id])
}

/// バックテスト個別イベント（各一致場面の結果）
model BacktestEvent {
  id         String          @id @default(uuid()) @db.Uuid
  /// 対応するバックテスト実行 ID
  runId      String          @db.Uuid
  /// エントリー時刻
  entryTime  DateTime        @db.Timestamptz(6)
  /// エントリー価格
  entryPrice Decimal         @db.Decimal(18, 8)
  /// 一致スコア
  matchScore Float
  /// 決済時刻
  exitTime   DateTime?       @db.Timestamptz(6)
  /// 決済価格
  exitPrice  Decimal?        @db.Decimal(18, 8)
  /// 結果（win: 利確到達、loss: 損切到達、timeout: タイムアウト）
  outcome    BacktestOutcome
  /// 損益（pips/ポイント）
  pnl        Decimal?        @db.Decimal(18, 8)
  /// 作成日時
  createdAt  DateTime        @default(now()) @db.Timestamptz(6)
  run        BacktestRun     @relation(fields: [runId], references: [id])

  @@index([runId, entryTime], map: "idx_backtestevent_run_entry")
}

/// Web Push 購読情報
model PushSubscription {
  id           String    @id @default(uuid()) @db.Uuid
  /// ユーザー識別子（将来のマルチユーザー対応用、現在は "default"）
  userId       String    @default("default")
  /// Push API エンドポイント URL
  endpoint     String    @unique
  /// 暗号化キー（p256dh）
  p256dh       String
  /// 認証シークレット
  auth         String
  /// 有効フラグ
  active       Boolean   @default(true)
  /// 最終プッシュ送信日時
  lastPushedAt DateTime? @db.Timestamptz(6)
  /// 連続失敗回数（リトライ制御用）
  failureCount Int       @default(0)
  /// 作成日時
  createdAt    DateTime  @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt    DateTime  @updatedAt @db.Timestamptz(6)

  @@index([userId, active], map: "idx_pushsub_user_active")
}

/// Push通知送信ログ
model PushLog {
  id             String        @id @default(uuid()) @db.Uuid
  /// 購読 ID
  subscriptionId String        @db.Uuid
  /// 通知 ID（Notification テーブルとの紐付け）
  notificationId String?       @db.Uuid
  /// 送信ステータス
  status         PushLogStatus @default(pending)
  /// エラーメッセージ
  errorMessage   String?
  /// リトライ回数
  retryCount     Int           @default(0)
  /// 送信日時
  sentAt         DateTime?     @db.Timestamptz(6)
  /// 作成日時
  createdAt      DateTime      @default(now()) @db.Timestamptz(6)

  @@index([subscriptionId, createdAt], map: "idx_pushlog_sub_created")
  @@index([status, createdAt], map: "idx_pushlog_status_created")
}

/// マッチング詳細（一致理由の内訳を保存）
model MatchDetail {
  id            String   @id @default(uuid()) @db.Uuid
  /// マッチ結果 ID
  matchResultId String   @db.Uuid
  /// 特徴量名（例: rsi, macd, trend）
  featureName   String
  /// ノート側の値
  noteValue     Float?
  /// スナップショット側の値
  snapshotValue Float?
  /// この特徴量の一致度（0.0〜1.0）
  similarity    Float
  /// 重み付け係数
  weight        Float    @default(1.0)
  /// 寄与度（similarity × weight）
  contribution  Float
  /// 異常値フラグ（Z-score が ±3σ を超えた場合）
  isAnomaly     Boolean  @default(false)
  /// 異常値の場合の詳細
  anomalyDetail String?
  /// 作成日時
  createdAt     DateTime @default(now()) @db.Timestamptz(6)

  @@index([matchResultId], map: "idx_matchdetail_matchresult")
}

/// ノートの承認状態
enum NoteStatus {
  draft
  approved
  rejected
}

enum TradeSide {
  buy
  sell
}

enum NotificationStatus {
  unread
  read
  deleted
}

enum NotificationLogStatus {
  sent
  skipped
  failed
}

enum RevaluationJobType {
  note_regenerate
  feature_recalculate
  ai_summary_regenerate
  full_reprocess
}

enum RevaluationJobStatus {
  pending
  running
  completed
  failed
  cancelled
}

enum BacktestStatus {
  pending
  running
  completed
  failed
}

enum BacktestOutcome {
  win
  loss
  timeout
}

enum PushLogStatus {
  pending
  sent
  failed
  retrying
}

// ============================================
// Strategy（ストラテジー）関連モデル
// Phase A: インジケーター条件ベースのバックテスト
// ============================================

/// ストラテジーステータス
enum StrategyStatus {
  draft     // 下書き
  active    // アクティブ（バックテスト・アラート対象）
  archived  // アーカイブ
}

/// ストラテジー（売買戦略の定義）
model Strategy {
  id               String            @id @default(uuid()) @db.Uuid
  /// ストラテジー名
  name             String
  /// 説明
  description      String?
  /// 対象シンボル（USDJPY, EURUSD, XAUUSD 等）
  symbol           String
  /// トレード方向（buy/sell）
  side             TradeSide
  /// ステータス
  status           StrategyStatus    @default(draft)
  /// 現在のバージョン ID
  currentVersionId String?           @db.Uuid
  /// タグ（検索・分類用）
  tags             String[]          @default([])
  /// 作成日時
  createdAt        DateTime          @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt        DateTime          @updatedAt @db.Timestamptz(6)
  /// バージョン履歴
  versions         StrategyVersion[]
  /// ストラテジーノート（優位性確認済みセットアップ）
  strategyNotes    StrategyNote[]
  /// ストラテジーバックテスト実行履歴
  backtestRuns     StrategyBacktestRun[]

  @@index([symbol], map: "idx_strategy_symbol")
  @@index([status], map: "idx_strategy_status")
  @@index([symbol, status], map: "idx_strategy_symbol_status")
}

/// ストラテジーバージョン（変更履歴）
/// 保存時に常に新バージョンを作成し、履歴を保持
model StrategyVersion {
  id               String   @id @default(uuid()) @db.Uuid
  /// 親ストラテジー ID
  strategyId       String   @db.Uuid
  /// バージョン番号（1, 2, 3...）
  versionNumber    Int
  /// エントリー条件（JSON: ConditionGroup）
  entryConditions  Json
  /// イグジット設定（JSON: ExitSettings）
  exitSettings     Json
  /// エントリータイミング（next_open 等）
  entryTiming      String   @default("next_open")
  /// 変更理由メモ
  changeNote       String?
  /// 作成日時
  createdAt        DateTime @default(now()) @db.Timestamptz(6)
  strategy         Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  @@unique([strategyId, versionNumber], map: "uq_strategyversion_strategy_version")
  @@index([strategyId], map: "idx_strategyversion_strategyid")
}

/// ストラテジーノート（優位性確認済みセットアップ）
/// バックテストで勝ったセットアップを保存し、パターン検出に活用
model StrategyNote {
  id             String   @id @default(uuid()) @db.Uuid
  /// 親ストラテジー ID
  strategyId     String   @db.Uuid
  /// エントリー時刻（バックテストで検出された時刻）
  entryTime      DateTime @db.Timestamptz(6)
  /// エントリー価格
  entryPrice     Decimal  @db.Decimal(18, 8)
  /// 一致した条件のスナップショット（JSON）
  conditionSnapshot Json
  /// インジケーター値のスナップショット（JSON）
  indicatorValues Json
  /// バックテスト結果（win/loss/timeout）
  outcome        BacktestOutcome
  /// 損益
  pnl            Decimal? @db.Decimal(18, 8)
  /// メモ
  notes          String?
  /// 作成日時
  createdAt      DateTime @default(now()) @db.Timestamptz(6)
  strategy       Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  @@index([strategyId], map: "idx_strategynote_strategyid")
  @@index([strategyId, outcome], map: "idx_strategynote_strategy_outcome")
}

/// ストラテジーバックテスト実行（ストラテジー条件ベース）
model StrategyBacktestRun {
  id                String                   @id @default(uuid()) @db.Uuid
  /// 対象ストラテジー ID
  strategyId        String                   @db.Uuid
  /// 使用したバージョン ID
  versionId         String                   @db.Uuid
  /// 銘柄シンボル
  symbol            String
  /// 時間足（例: 15m, 1h, 4h）
  timeframe         String
  /// バックテスト開始日
  startDate         DateTime                 @db.Timestamptz(6)
  /// バックテスト終了日
  endDate           DateTime                 @db.Timestamptz(6)
  /// ステージ（stage1: 高速スキャン、stage2: 1分足精密検証）
  stage             String                   @default("stage1")
  /// 実行状態
  status            BacktestStatus           @default(pending)
  /// 作成日時
  createdAt         DateTime                 @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt         DateTime                 @updatedAt @db.Timestamptz(6)
  strategy          Strategy                 @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  events            StrategyBacktestEvent[]
  result            StrategyBacktestResult?

  @@index([strategyId], map: "idx_strategybacktestrun_strategyid")
  @@index([status, createdAt], map: "idx_strategybacktestrun_status_created")
}

/// ストラテジーバックテスト集計結果
model StrategyBacktestResult {
  id           String              @id @default(uuid()) @db.Uuid
  /// 対応するバックテスト実行 ID
  runId        String              @unique @db.Uuid
  /// セットアップ出現回数
  setupCount   Int
  /// 勝ちトレード数
  winCount     Int
  /// 負けトレード数
  lossCount    Int
  /// タイムアウト数
  timeoutCount Int
  /// 勝率（0.0〜1.0）
  winRate      Float
  /// プロフィットファクター（総利益/総損失）
  profitFactor Float?
  /// 総利益
  totalProfit  Decimal             @db.Decimal(18, 8)
  /// 総損失
  totalLoss    Decimal             @db.Decimal(18, 8)
  /// 平均損益
  averagePnL   Decimal             @db.Decimal(18, 8)
  /// 期待値
  expectancy   Decimal             @db.Decimal(18, 8)
  /// 最大ドローダウン
  maxDrawdown  Decimal?            @db.Decimal(18, 8)
  /// 計算完了日時
  completedAt  DateTime            @default(now()) @db.Timestamptz(6)
  run          StrategyBacktestRun @relation(fields: [runId], references: [id], onDelete: Cascade)
}

/// ストラテジーバックテスト個別イベント
model StrategyBacktestEvent {
  id              String              @id @default(uuid()) @db.Uuid
  /// 対応するバックテスト実行 ID
  runId           String              @db.Uuid
  /// エントリー時刻
  entryTime       DateTime            @db.Timestamptz(6)
  /// エントリー価格
  entryPrice      Decimal             @db.Decimal(18, 8)
  /// 条件成立時のインジケーター値（JSON）
  indicatorValues Json?
  /// 決済時刻
  exitTime        DateTime?           @db.Timestamptz(6)
  /// 決済価格
  exitPrice       Decimal?            @db.Decimal(18, 8)
  /// 結果
  outcome         BacktestOutcome
  /// 損益
  pnl             Decimal?            @db.Decimal(18, 8)
  /// 作成日時
  createdAt       DateTime            @default(now()) @db.Timestamptz(6)
  run             StrategyBacktestRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId, entryTime], map: "idx_strategybacktestevent_run_entry")
}
