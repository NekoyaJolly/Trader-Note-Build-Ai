generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Trade {
  id        String     @id @default(uuid()) @db.Uuid
  timestamp DateTime   @db.Timestamptz(6)
  symbol    String
  side      TradeSide
  price     Decimal    @db.Decimal(18, 8)
  quantity  Decimal    @db.Decimal(18, 8)
  fee       Decimal?   @db.Decimal(18, 8)
  exchange  String?
  createdAt DateTime   @default(now()) @db.Timestamptz(6)
  updatedAt DateTime   @updatedAt @db.Timestamptz(6)
  note      TradeNote?

  @@index([symbol, timestamp], map: "idx_trade_symbol_timestamp")
}

model TradeNote {
  id               String            @id @default(uuid()) @db.Uuid
  tradeId          String            @unique @db.Uuid
  symbol           String
  entryPrice       Decimal           @db.Decimal(18, 8)
  side             TradeSide
  indicators       Json?
  featureVector    Float[]
  timeframe        String?
  createdAt        DateTime          @default(now()) @db.Timestamptz(6)
  updatedAt        DateTime          @updatedAt @db.Timestamptz(6)
  aiSummary        AISummary?
  matchResult      MatchResult[]
  notificationLogs NotificationLog[] @relation("NotificationLogNote")
  trade            Trade             @relation(fields: [tradeId], references: [id])

  @@index([symbol], map: "idx_tradenote_symbol")
}

model AISummary {
  id               String    @id @default(uuid()) @db.Uuid
  noteId           String    @unique @db.Uuid
  summary          String
  promptTokens     Int?
  completionTokens Int?
  model            String?
  createdAt        DateTime  @default(now()) @db.Timestamptz(6)
  note             TradeNote @relation(fields: [noteId], references: [id])
}

model MarketSnapshot {
  id               String            @id @default(uuid()) @db.Uuid
  symbol           String
  timeframe        String
  close            Decimal           @db.Decimal(18, 8)
  volume           Decimal           @db.Decimal(18, 8)
  indicators       Json
  fetchedAt        DateTime          @db.Timestamptz(6)
  createdAt        DateTime          @default(now()) @db.Timestamptz(6)
  matchResults     MatchResult[]
  notificationLogs NotificationLog[] @relation("NotificationLogSnapshot")

  @@unique([symbol, timeframe, fetchedAt], map: "uq_snapshot_symbol_timeframe_fetched")
  @@index([symbol, timeframe], map: "idx_snapshot_symbol_timeframe")
}

model MatchResult {
  id                String         @id @default(uuid()) @db.Uuid
  noteId            String         @db.Uuid
  marketSnapshotId  String         @db.Uuid
  symbol            String
  score             Float
  threshold         Float
  trendMatched      Boolean
  priceRangeMatched Boolean
  decidedAt         DateTime       @default(now()) @db.Timestamptz(6)
  createdAt         DateTime       @default(now()) @db.Timestamptz(6)
  evaluatedAt       DateTime       @default(now()) @db.Timestamptz(6)
  reasons           Json
  marketSnapshot    MarketSnapshot @relation(fields: [marketSnapshotId], references: [id])
  note              TradeNote      @relation(fields: [noteId], references: [id])
  notifications     Notification[]
  orderPresets      OrderPreset[]

  @@unique([noteId, marketSnapshotId], map: "uq_match_note_snapshot")
  @@index([symbol, decidedAt], map: "idx_match_symbol_decided")
}

model Notification {
  id            String             @id @default(uuid()) @db.Uuid
  matchResultId String             @db.Uuid
  title         String
  message       String
  status        NotificationStatus @default(unread)
  sentAt        DateTime           @default(now()) @db.Timestamptz(6)
  readAt        DateTime?          @db.Timestamptz(6)
  createdAt     DateTime           @default(now()) @db.Timestamptz(6)
  matchResult   MatchResult        @relation(fields: [matchResultId], references: [id])

  @@index([status, sentAt], map: "idx_notification_status_sent")
}

model OrderPreset {
  id                String      @id @default(uuid()) @db.Uuid
  matchResultId     String      @db.Uuid
  symbol            String
  side              TradeSide
  suggestedPrice    Decimal     @db.Decimal(18, 8)
  suggestedQuantity Decimal     @db.Decimal(18, 8)
  confidence        Float
  feesEstimate      Decimal?    @db.Decimal(18, 8)
  createdAt         DateTime    @default(now()) @db.Timestamptz(6)
  matchResult       MatchResult @relation(fields: [matchResultId], references: [id])

  @@index([symbol, createdAt], map: "idx_orderpreset_symbol_created")
}

model NotificationLog {
  id               String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  noteId           String                @db.Uuid
  marketSnapshotId String                @db.Uuid
  symbol           String
  score            Float
  channel          String
  status           NotificationLogStatus @default(sent)
  reasonSummary    String
  sentAt           DateTime              @default(now()) @db.Timestamptz(6)
  createdAt        DateTime              @default(now()) @db.Timestamptz(6)
  marketSnapshot   MarketSnapshot        @relation("NotificationLogSnapshot", fields: [marketSnapshotId], references: [id])
  note             TradeNote             @relation("NotificationLogNote", fields: [noteId], references: [id])

  @@unique([noteId, marketSnapshotId, channel], map: "uq_notiflog_note_snapshot_channel")
  @@index([symbol, sentAt], map: "idx_notiflog_symbol_sent")
  @@index([noteId, sentAt], map: "idx_notiflog_note_sent")
}

enum TradeSide {
  buy
  sell
}

enum NotificationStatus {
  unread
  read
  deleted
}

enum NotificationLogStatus {
  sent
  skipped
  failed
}

// ============================================
// OHLCV 時系列データ（TimescaleDB 対応準備）
// 技術スタック選定シート ③ に基づく
// ============================================

/// OHLCV ローソク足データ
/// 将来的に TimescaleDB のハイパーテーブルに変換予定
/// 変換 SQL: SELECT create_hypertable('OHLCVCandle', 'timestamp');
model OHLCVCandle {
  id        String   @id @default(uuid()) @db.Uuid
  /// 銘柄シンボル（例: BTCUSD, EURUSD）
  symbol    String
  /// 時間足（例: 1m, 5m, 15m, 1h, 4h, 1d）
  timeframe String
  /// ローソク足開始時刻（UTC）
  timestamp DateTime @db.Timestamptz(6)
  /// 始値
  open      Decimal  @db.Decimal(18, 8)
  /// 高値
  high      Decimal  @db.Decimal(18, 8)
  /// 安値
  low       Decimal  @db.Decimal(18, 8)
  /// 終値
  close     Decimal  @db.Decimal(18, 8)
  /// 出来高
  volume    Decimal  @db.Decimal(18, 8)
  /// データソース（例: twelvedata, binance）
  source    String?
  /// 作成日時
  createdAt DateTime @default(now()) @db.Timestamptz(6)

  // 複合ユニーク制約（同一銘柄・時間足・時刻の重複防止）
  @@unique([symbol, timeframe, timestamp], map: "uq_ohlcv_symbol_timeframe_timestamp")
  // 時系列クエリ用インデックス
  @@index([symbol, timeframe, timestamp], map: "idx_ohlcv_symbol_timeframe_timestamp")
  // 銘柄別クエリ用インデックス
  @@index([symbol, timestamp], map: "idx_ohlcv_symbol_timestamp")
}

/// Raw JSON 形式のトレードノート保存
/// 技術スタック選定シート ⑧ に基づくハイブリッド保存
model TradeNoteRaw {
  id        String   @id @default(uuid()) @db.Uuid
  /// 関連するトレードノート ID
  noteId    String   @unique @db.Uuid
  /// Raw JSON データ（将来の再評価・再生成用）
  rawData   Json
  /// スキーマバージョン（破壊的変更対応）
  version   Int      @default(1)
  /// 作成日時
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt DateTime @updatedAt @db.Timestamptz(6)

  @@index([noteId], map: "idx_tradenoteraw_noteid")
}

/// 再評価ジョブ管理
/// 技術スタック選定シート ⑨ に基づく
model RevaluationJob {
  id           String               @id @default(uuid()) @db.Uuid
  /// ジョブタイプ（note_regenerate, feature_recalculate, ai_summary_regenerate）
  jobType      RevaluationJobType
  /// 対象ノート ID（null の場合は全ノート対象）
  targetNoteId String?              @db.Uuid
  /// 対象銘柄（null の場合は全銘柄対象）
  targetSymbol String?
  /// ジョブ状態
  status       RevaluationJobStatus @default(pending)
  /// 処理済み件数
  processedCount Int               @default(0)
  /// 総件数
  totalCount     Int               @default(0)
  /// エラーメッセージ
  errorMessage   String?
  /// 開始日時
  startedAt      DateTime?         @db.Timestamptz(6)
  /// 完了日時
  completedAt    DateTime?         @db.Timestamptz(6)
  /// 作成日時
  createdAt      DateTime          @default(now()) @db.Timestamptz(6)
  /// 更新日時
  updatedAt      DateTime          @updatedAt @db.Timestamptz(6)

  @@index([status, createdAt], map: "idx_revaluationjob_status_created")
  @@index([jobType, status], map: "idx_revaluationjob_type_status")
}

enum RevaluationJobType {
  note_regenerate
  feature_recalculate
  ai_summary_regenerate
  full_reprocess
}

enum RevaluationJobStatus {
  pending
  running
  completed
  failed
  cancelled
}
